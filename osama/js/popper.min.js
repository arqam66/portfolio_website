/**
 * @popperjs/core v2.9.2 - MIT License
 */

"use strict";

(function (global, factory) {
  if (typeof exports === "object" && typeof module !== "undefined") {
    factory(exports);
  } else if (typeof define === "function" && define.amd) {
    define(["exports"], factory);
  } else {
    factory((global = typeof globalThis !== "undefined" ? globalThis : global || self).Popper = {});
  }
})(this, function (exports) {
  // Helper functions
  function getRect(element) {
    const rect = element.getBoundingClientRect();
    return {
      width: rect.width,
      height: rect.height,
      top: rect.top,
      right: rect.right,
      bottom: rect.bottom,
      left: rect.left,
      x: rect.left,
      y: rect.top,
    };
  }

  function getWindow(element) {
    if (element == null) return window;
    if (Object.prototype.toString.call(element) === "[object Window]") return element;
    const ownerDocument = element.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }

  function getScroll(element) {
    const win = getWindow(element);
    return {
      scrollLeft: win.pageXOffset,
      scrollTop: win.pageYOffset,
    };
  }

  function isElement(node) {
    const win = getWindow(node);
    return node instanceof win.Element || node instanceof Element;
  }

  function isHTMLElement(node) {
    const win = getWindow(node);
    return node instanceof win.HTMLElement || node instanceof HTMLElement;
  }

  function isShadowRoot(node) {
    const win = getWindow(node);
    return typeof ShadowRoot !== "undefined" && (node instanceof win.ShadowRoot || node instanceof ShadowRoot);
  }

  function getNodeName(node) {
    return node ? (node.nodeName || "").toLowerCase() : null;
  }

  function getDocumentElement(element) {
    return (
      (isElement(element) ? element.ownerDocument : element.document) || window.document
    ).documentElement;
  }

  function getOffsetParent(element) {
    const win = getWindow(element);
    let offsetParent = element.offsetParent;

    while (offsetParent && getNodeName(offsetParent) === "table" && getComputedStyle(offsetParent).position === "static") {
      offsetParent = offsetParent.offsetParent;
    }

    return offsetParent || win;
  }

  // Core logic and functions
  function computeOffsets({ reference, element, placement }) {
    const basePlacement = placement ? placement.split("-")[0] : null;
    const variation = placement ? placement.split("-")[1] : null;

    const isVertical = basePlacement === "top" || basePlacement === "bottom";
    const mainAxis = isVertical ? "y" : "x";

    let offsets = {
      x: reference.x + reference.width / 2 - element.width / 2,
      y: reference.y + reference.height / 2 - element.height / 2,
    };

    switch (basePlacement) {
      case "top":
        offsets.y = reference.y - element.height;
        break;
      case "bottom":
        offsets.y = reference.y + reference.height;
        break;
      case "right":
        offsets.x = reference.x + reference.width;
        break;
      case "left":
        offsets.x = reference.x - element.width;
        break;
    }

    const mainSize = mainAxis === "y" ? "height" : "width";

    if (variation === "start") {
      offsets[mainAxis] -= reference[mainSize] / 2 - element[mainSize] / 2;
    } else if (variation === "end") {
      offsets[mainAxis] += reference[mainSize] / 2 - element[mainSize] / 2;
    }

    return offsets;
  }

  // Exported functions
  exports.computeOffsets = computeOffsets;
});
